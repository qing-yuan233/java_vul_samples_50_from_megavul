[
    {
        "cve_id": "CVE-2022-28367",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "private boolean processStyleTag(Element ele, Node parentNode) {\n        /*\n         * Invoke the css parser on this element.\n         */\n        CssScanner styleScanner = new CssScanner(policy, messages, policy.isEmbedStyleSheets());\n\n        try {\n            Node firstChild = ele.getFirstChild();\n            if (firstChild != null) {\n\n                String toScan = firstChild.getNodeValue();\n                CleanResults cr = styleScanner.scanStyleSheet(toScan, policy.getMaxInputSize());\n                errorMessages.addAll(cr.getErrorMessages());\n\n                /*\n                 * If IE gets an empty style tag, i.e. <style/> it will\n                 * break all CSS on the page. I wish I was kidding. So,\n                 * if after validation no CSS properties are left, we\n                 * would normally be left with an empty style tag and\n                 * break all CSS. To prevent that, we have this check.\n                 */\n\n                final String cleanHTML = cr.getCleanHTML();\n\n                if (cleanHTML == null || cleanHTML.equals(\"\")) {\n                    firstChild.setNodeValue(\"/* */\");\n                } else {\n                    firstChild.setNodeValue(cleanHTML);\n                }\n            }\n\n        } catch (DOMException | ScanException | ParseException | NumberFormatException e) {\n\n            /*\n             * ParseException shouldn't be possible anymore, but we'll leave it\n             * here because I (Arshan) am hilariously dumb sometimes.\n             * Batik can throw NumberFormatExceptions (see bug #48).\n             */\n\n            addError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[]{HTMLEntityEncoder.htmlEntityEncode(ele.getFirstChild().getNodeValue())});\n            parentNode.removeChild(ele);\n            return true;\n        }\n        return false;\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-26480",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "@Override\n    public List<Block> execute(LiveDataMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        // Load the JavaScript code of the Live Data widget.\n        Map<String, Object> skinExtensionParameters = Collections.singletonMap(\"forceSkinAction\", Boolean.TRUE);\n        this.jsfx.use(\"uicomponents/widgets/liveData.js\", skinExtensionParameters);\n\n        GroupBlock output = new GroupBlock();\n        output.setParameter(\"class\", \"liveData loading\");\n        if (parameters.getId() != null) {\n            output.setParameter(\"id\", parameters.getId());\n        }\n        try {\n            // Compute the live data configuration based on the macro parameters.\n            LiveDataConfiguration liveDataConfig = getLiveDataConfiguration(content, parameters);\n            // Add the default values.\n            liveDataConfig = this.defaultLiveDataConfigResolver.resolve(liveDataConfig);\n            // Serialize as JSON.\n            ObjectMapper objectMapper = new ObjectMapper();\n            output.setParameter(\"data-config\", objectMapper.writeValueAsString(liveDataConfig));\n        } catch (Exception e) {\n            throw new MacroExecutionException(\"Failed to generate live data configuration from macro parameters.\", e);\n        }\n        return Collections.singletonList(output);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2013-6465",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "public void onTaskSelectionEvent(@Observes TaskSelectionEvent event){\n        selectedTaskId = event.getTaskId();\n        selectedTaskName = event.getTaskName();\n        \n        view.getTaskIdAndName().setText(String.valueOf(selectedTaskId) + \" - \"+selectedTaskName);\n        \n        view.getContent().clear();\n        \n        String placeToGo;\n        if(event.getPlace() != null && !event.getPlace().equals(\"\")){\n            placeToGo = event.getPlace();\n        }else{\n            placeToGo = \"Task Details\";\n        }\n        \n        \n\n        DefaultPlaceRequest defaultPlaceRequest = new DefaultPlaceRequest(placeToGo);\n        //Set Parameters here: \n        defaultPlaceRequest.addParameter(\"taskId\", String.valueOf(selectedTaskId));\n        defaultPlaceRequest.addParameter(\"taskName\", selectedTaskName);\n\n        Set<Activity> activities = activityManager.getActivities(defaultPlaceRequest);\n        AbstractWorkbenchScreenActivity activity = ((AbstractWorkbenchScreenActivity) activities.iterator().next());\n        \n        activitiesMap.put(placeToGo, activity);\n        \n        IsWidget widget = activity.getWidget();\n        activity.launch(place, null);\n        activity.onStartup(defaultPlaceRequest);\n        view.getContent().add(widget);\n        activity.onOpen();\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2022-23391",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "@RequiresPermissions(\"user:list\")\n    @GetMapping(\"/list\")\n    public String list(@RequestParam(defaultValue = \"1\") Integer pageNo, String username, Model model) {\n//        username= SecurityUtil.sanitizeInput(username);\n        IPage<User> iPage = userService.selectAll(pageNo, username);\n        model.addAttribute(\"page\", iPage);\n        model.addAttribute(\"username\", username);\n        return \"admin/user/list\";\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-47324",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "@Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n      throws IOException, ServletException {\n\n    HttpServletRequest httpRequest = (HttpServletRequest) request;\n    if (SecuritySettings.isWebSecurityByTokensEnabled() && isProtectedResource(httpRequest)) {\n      try {\n        checkAuthenticatedRequest(httpRequest);\n        tokenService.validate(httpRequest);\n        chain.doFilter(request, response);\n      } catch (TokenValidationException ex) {\n        logger.error(\"The request for path {0} isn''t valid: {1}\", pathOf(request), ex.getMessage());\n        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_FORBIDDEN);\n      } catch (UnauthenticatedRequestException ex) {\n        logger.error(\"The request for path {0} isn''t sent within an opened session\",\n            pathOf(request));\n        redirectToAuthenticationPage(request, response);\n      }\n    } else {\n      chain.doFilter(request, response);\n    }\n  }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-29206",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "private String getCanonicalDocumentName(String documentName)\n    {\n        @SuppressWarnings(\"unchecked\")\n        EntityReferenceResolver<String> resolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"current\");\n        @SuppressWarnings(\"unchecked\")\n        EntityReferenceSerializer<String> serializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        return serializer.serialize(resolver.resolve(documentName, EntityType.DOCUMENT));\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2019-16643",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "public Version getLastVersion(boolean fetch) {\n        boolean checkPreview = previewAble();\n        if (updateVersionTimerTask == null) {\n            updateVersionTimerTask = new UpdateVersionTimerTask(checkPreview);\n        }\n        if (fetch) {\n            try {\n                return updateVersionTimerTask.fetchLastVersion(checkPreview);\n            } catch (Exception e) {\n                LOGGER.error(e);\n            }\n        }\n        return updateVersionTimerTask.getVersion();\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2017-12647",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "@Override\n\tpublic KBTemplate updateImpl(KBTemplate kbTemplate) {\n\t\tkbTemplate = toUnwrappedModel(kbTemplate);\n\n\t\tboolean isNew = kbTemplate.isNew();\n\n\t\tKBTemplateModelImpl kbTemplateModelImpl = (KBTemplateModelImpl)kbTemplate;\n\n\t\tif (Validator.isNull(kbTemplate.getUuid())) {\n\t\t\tString uuid = PortalUUIDUtil.generate();\n\n\t\t\tkbTemplate.setUuid(uuid);\n\t\t}\n\n\t\tServiceContext serviceContext = ServiceContextThreadLocal.getServiceContext();\n\n\t\tDate now = new Date();\n\n\t\tif (isNew && (kbTemplate.getCreateDate() == null)) {\n\t\t\tif (serviceContext == null) {\n\t\t\t\tkbTemplate.setCreateDate(now);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkbTemplate.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\t}\n\t\t}\n\n\t\tif (!kbTemplateModelImpl.hasSetModifiedDate()) {\n\t\t\tif (serviceContext == null) {\n\t\t\t\tkbTemplate.setModifiedDate(now);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkbTemplate.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\t}\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tif (kbTemplate.isNew()) {\n\t\t\t\tsession.save(kbTemplate);\n\n\t\t\t\tkbTemplate.setNew(false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tkbTemplate = (KBTemplate)session.merge(kbTemplate);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\n\t\tfinderCache.clearCache(FINDER_CLASS_NAME_LIST_WITH_PAGINATION);\n\n\t\tif (!KBTemplateModelImpl.COLUMN_BITMASK_ENABLED) {\n\t\t\tfinderCache.clearCache(FINDER_CLASS_NAME_LIST_WITHOUT_PAGINATION);\n\t\t}\n\t\telse\n\t\t if (isNew) {\n\t\t\tObject[] args = new Object[] { kbTemplateModelImpl.getUuid() };\n\n\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_UUID, args);\n\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID,\n\t\t\t\targs);\n\n\t\t\targs = new Object[] {\n\t\t\t\t\tkbTemplateModelImpl.getUuid(),\n\t\t\t\t\tkbTemplateModelImpl.getCompanyId()\n\t\t\t\t};\n\n\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_UUID_C, args);\n\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID_C,\n\t\t\t\targs);\n\n\t\t\targs = new Object[] { kbTemplateModelImpl.getGroupId() };\n\n\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_GROUPID, args);\n\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_GROUPID,\n\t\t\t\targs);\n\n\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_ALL, FINDER_ARGS_EMPTY);\n\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_ALL,\n\t\t\t\tFINDER_ARGS_EMPTY);\n\t\t}\n\n\t\telse {\n\t\t\tif ((kbTemplateModelImpl.getColumnBitmask() &\n\t\t\t\t\tFINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID.getColumnBitmask()) != 0) {\n\t\t\t\tObject[] args = new Object[] {\n\t\t\t\t\t\tkbTemplateModelImpl.getOriginalUuid()\n\t\t\t\t\t};\n\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_UUID, args);\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID,\n\t\t\t\t\targs);\n\n\t\t\t\targs = new Object[] { kbTemplateModelImpl.getUuid() };\n\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_UUID, args);\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID,\n\t\t\t\t\targs);\n\t\t\t}\n\n\t\t\tif ((kbTemplateModelImpl.getColumnBitmask() &\n\t\t\t\t\tFINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID_C.getColumnBitmask()) != 0) {\n\t\t\t\tObject[] args = new Object[] {\n\t\t\t\t\t\tkbTemplateModelImpl.getOriginalUuid(),\n\t\t\t\t\t\tkbTemplateModelImpl.getOriginalCompanyId()\n\t\t\t\t\t};\n\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_UUID_C, args);\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID_C,\n\t\t\t\t\targs);\n\n\t\t\t\targs = new Object[] {\n\t\t\t\t\t\tkbTemplateModelImpl.getUuid(),\n\t\t\t\t\t\tkbTemplateModelImpl.getCompanyId()\n\t\t\t\t\t};\n\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_UUID_C, args);\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_UUID_C,\n\t\t\t\t\targs);\n\t\t\t}\n\n\t\t\tif ((kbTemplateModelImpl.getColumnBitmask() &\n\t\t\t\t\tFINDER_PATH_WITHOUT_PAGINATION_FIND_BY_GROUPID.getColumnBitmask()) != 0) {\n\t\t\t\tObject[] args = new Object[] {\n\t\t\t\t\t\tkbTemplateModelImpl.getOriginalGroupId()\n\t\t\t\t\t};\n\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_GROUPID, args);\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_GROUPID,\n\t\t\t\t\targs);\n\n\t\t\t\targs = new Object[] { kbTemplateModelImpl.getGroupId() };\n\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_COUNT_BY_GROUPID, args);\n\t\t\t\tfinderCache.removeResult(FINDER_PATH_WITHOUT_PAGINATION_FIND_BY_GROUPID,\n\t\t\t\t\targs);\n\t\t\t}\n\t\t}\n\n\t\tentityCache.putResult(KBTemplateModelImpl.ENTITY_CACHE_ENABLED,\n\t\t\tKBTemplateImpl.class, kbTemplate.getPrimaryKey(), kbTemplate, false);\n\n\t\tclearUniqueFindersCache(kbTemplateModelImpl, false);\n\t\tcacheUniqueFindersCache(kbTemplateModelImpl);\n\n\t\tkbTemplate.resetOriginalValues();\n\n\t\treturn kbTemplate;\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-29206",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "private void onDocumentEvent(XWikiDocument document)\n    {\n        boolean remove = false;\n        if (document.getObject(getExtensionClassName()) != null) {\n            // new or already existing object\n            if (document.getObject(getExtensionClassName(), USE_FIELDNAME, \"always\", false) != null) {\n                if (Utils.getComponent(AuthorizationManager.class).hasAccess(Right.PROGRAM,\n                    document.getAuthorReference(), document.getDocumentReference())) {\n                    getAlwaysUsedExtensions().add(document.getDocumentReference());\n\n                    return;\n                } else {\n                    // in case the extension lost its programming rights upon this save.\n                    remove = true;\n                }\n            } else {\n                // remove if exists but use onDemand\n                remove = true;\n            }\n        } else if (document.getOriginalDocument().getObject(getExtensionClassName()) != null) {\n            // object removed\n            remove = true;\n        }\n\n        if (remove) {\n            getAlwaysUsedExtensions().remove(document.getDocumentReference());\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2018-25097",
        "cwe_ids": [
            "CWE-79"
        ],
        "func_before": "@ApiOperation(value = \"Modify Node Operation\")\n\t@RequestMapping(value = \"/modifyNode\", method = RequestMethod.POST)\n\t@ResponseBody\n\tpublic String modifyNode(@RequestParam(value = \"userid\", required = true) String userId,\n\t\t\t@RequestParam(value = \"solutionid\", required = false) String solutionId,\n\t\t\t@RequestParam(value = \"version\", required = false) String version,\n\t\t\t@RequestParam(value = \"cid\", required = false) String cid,\n\t\t\t@RequestParam(value = \"nodeid\", required = true) String nodeId,\n\t\t\t@RequestParam(value = \"nodename\", required = false) String nodeName,\n\t\t\t@RequestParam(value = \"ndata\", required = false) String ndata,\n\t\t\t@RequestBody(required = false) DataConnector dataConnector) {\n\t\t\n\t\tString result = null;\n\t\tFieldMap fieldMap = null;\n\t\tDataBrokerMap databrokerMap = null;\n\t\tCollatorMap collatorMap = null;\n\t\tSplitterMap  splitterMap = null;\n\t\tlogger.debug(EELFLoggerDelegator.debugLogger, \"------- modifyNode() ------- : Begin\");\n\t\ttry {\n\t\t\tif(null != dataConnector){\n\t\t\t\tif(null != dataConnector.getFieldMap()){\n\t\t\t\t\tfieldMap = dataConnector.getFieldMap();\n\t\t\t\t}\n\t\t\t\tif(null != dataConnector.getDatabrokerMap()){\n\t\t\t\t\tdatabrokerMap = dataConnector.getDatabrokerMap();\n\t\t\t\t}\n\t\t\t\tif(null != dataConnector.getCollatorMap()){\n\t\t\t\t\tcollatorMap = dataConnector.getCollatorMap();\n\t\t\t\t}\n\t\t\t\tif(null != dataConnector.getSplitterMap()){\n\t\t\t\t\tsplitterMap = dataConnector.getSplitterMap();\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = solutionService.modifyNode(userId, solutionId, version, cid, nodeId, nodeName, ndata, fieldMap, databrokerMap, collatorMap, splitterMap);\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(EELFLoggerDelegator.errorLogger, \"-------Exception in  modifyNode() -------\", e);\n\t\t}\n\t\tlogger.debug(EELFLoggerDelegator.debugLogger, \"------- modifyNode() ------- : End\");\n\t\treturn result;\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2013-10013",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "public AuthenticatedUser authenticate(String username, String password,\n\t\t\tString ipaddress) throws AuthenticationException {\n\t\tAuthenticatedUser user = null;\n\t\tif (username == null || username.trim().length() == 0\n\t\t\t\t|| password == null || password.trim().length() == 0) {\n\t\t\tthrow new AuthenticationException(\n\t\t\t\t\t\"Authentication failed: Invalid arguments\");\n\t\t}\n\t\ttry {\n\n\t\t\tContentManager contentManager = ContentManager.getContentManager();\n\t\t\tList result = new ArrayList();\n\t\t\tString sql = \"SELECT * FROM \" + table + \" WHERE \"\n\t\t\t\t\t+ columns.get(\"username\") + \"= ? AND \"\n\t\t\t\t\t+ columns.get(\"password\") + \"= '?'\";\n\t\t\t\n\t\t\tString[] preparedVariables = new String[] {username, password};\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(log.isDebugEnabled()) {\n\t\t\t\tlog.debug(sql);\n\t\t\t}\n\t\t\tcontentManager.doQuery(new Query(sql, preparedVariables, result));\n\t\t\t\n\t\t\tif(log.isDebugEnabled()) {\n\t\t\t\tlog.debug(\"found \" + result.size() + \" records\");\n\t\t\t}\n\t\t\tif(result.size() > 0) {\n\t\t\t\t// get the first found row and create user object\n\t\t\t\tMap row = (Map) result.get(0);\n\n\t\t\t\t// intantiate the user class an add the map\n\t\t\t\tClass clazz = Class.forName(userClass);\n\t\t\t\tif(log.isDebugEnabled()) {\n\t\t\t\t\tlog.debug(\"creating user class \" + clazz.getName());\n\t\t\t\t}\n\t\t\t\tDBUser dbUser = (DBUser)clazz.newInstance();\n\t\t\t\tdbUser.init(row);\n\t\t\t\tuser = dbUser;\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"Authentication failed: Finding user failed\");\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\tif (user == null) {\n\t\t\tthrow new AuthenticationException(\n\t\t\t\t\t\"Authentication failed: User not found\");\n\t\t}\n\t\treturn user;\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-1495",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "public static String generateQuickCode(String nameVal) {\n        if (StringUtils.isBlank(nameVal)) return StringUtils.EMPTY;\n\n        if (nameVal.length() > 100) nameVal = nameVal.substring(0, 100);\n\n        if (EasyPhone.isPhone(nameVal) || EasyEmail.isEmail(nameVal) || EasyUrl.isUrl(nameVal)) return StringUtils.EMPTY;\n\n        // 提取 0-9+a-z+A-Z+中文+空格，忽略特殊字符\n        nameVal = nameVal.replaceAll(\"[^a-zA-Z0-9\\\\s\\u4e00-\\u9fa5]\", \"\");\n        // 忽略数字或小字母\n        if (nameVal.matches(\"[a-z0-9]+\")) return StringUtils.EMPTY;\n\n        String quickCode = StringUtils.EMPTY;\n\n        // 仅包含字母数字或空格\n        if (nameVal.matches(\"[a-zA-Z0-9\\\\s]+\")) {\n            // 提取英文单词的首字母\n            String[] asplit = nameVal.split(\"(?=[A-Z\\\\s])\");\n            if (asplit.length == 1) {\n                quickCode = nameVal;\n            } else {\n                StringBuilder sb = new StringBuilder();\n                for (String a : asplit) {\n                    if (a.trim().length() > 0) {\n                        sb.append(a.trim(), 0, 1);\n                    }\n                }\n                quickCode = sb.toString();\n            }\n\n        } else {\n            // 拼音首字母\n            nameVal = nameVal.replaceAll(\" \", \"\");\n            try {\n                quickCode = HanLP.convertToPinyinFirstCharString(nameVal, \"\", false);\n            } catch (Exception e) {\n                log.error(\"QuickCode shorting error : \" + nameVal, e);\n            }\n        }\n\n        return CommonsUtils.maxstr(quickCode, 50).toUpperCase();\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2022-24848",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "private void auditTeav( TrackedEntityAttributeValue av, TrackedEntityAttributeValue createOrUpdateTeav,\n        org.hisp.dhis.common.AuditType auditType )\n    {\n        String currentUsername = currentUserService.getCurrentUsername();\n\n        TrackedEntityAttributeValueAudit deleteTeavAudit = new TrackedEntityAttributeValueAudit( av, av.getAuditValue(),\n            currentUsername, DELETE );\n        TrackedEntityAttributeValueAudit updatedTeavAudit = new TrackedEntityAttributeValueAudit( createOrUpdateTeav,\n            createOrUpdateTeav.getValue(), currentUsername, auditType );\n\n        if ( config.isEnabled( CHANGELOG_TRACKER ) )\n        {\n            trackedEntityAttributeValueAuditService.addTrackedEntityAttributeValueAudit( deleteTeavAudit );\n            trackedEntityAttributeValueAuditService.addTrackedEntityAttributeValueAudit( updatedTeavAudit );\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2020-9483",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "@Override\n    public Thermodynamic getThermodynamic(String tableName, DownSampling downsampling, List<String> ids,\n                                          String valueCName) throws IOException {\n        StringBuilder idValues = new StringBuilder();\n        for (int valueIdx = 0; valueIdx < ids.size(); valueIdx++) {\n            if (valueIdx != 0) {\n                idValues.append(\",\");\n            }\n            idValues.append(\"'\").append(ids.get(valueIdx)).append(\"'\");\n        }\n\n        List<List<Long>> thermodynamicValueCollection = new ArrayList<>();\n        Map<String, List<Long>> thermodynamicValueMatrix = new HashMap<>();\n\n        try (Connection connection = h2Client.getConnection()) {\n            Thermodynamic thermodynamic = new Thermodynamic();\n            int numOfSteps = 0;\n            int axisYStep = 0;\n            try (ResultSet resultSet = h2Client.executeQuery(\n                connection,\n                \"select \" + ThermodynamicMetrics.STEP + \" step, \" + ThermodynamicMetrics.NUM_OF_STEPS + \" num_of_steps, \" + ThermodynamicMetrics.DETAIL_GROUP + \" detail_group, \" + \"id \" + \" from \" + tableName + \" where id in (\" + idValues\n                    .toString() + \")\"\n            )) {\n\n                while (resultSet.next()) {\n                    axisYStep = resultSet.getInt(\"step\");\n                    String id = resultSet.getString(\"id\");\n                    numOfSteps = resultSet.getInt(\"num_of_steps\") + 1;\n                    String value = resultSet.getString(\"detail_group\");\n                    IntKeyLongValueHashMap intKeyLongValues = new IntKeyLongValueHashMap(5);\n                    intKeyLongValues.toObject(value);\n\n                    List<Long> axisYValues = new ArrayList<>();\n                    for (int i = 0; i < numOfSteps; i++) {\n                        axisYValues.add(0L);\n                    }\n\n                    for (IntKeyLongValue intKeyLongValue : intKeyLongValues.values()) {\n                        axisYValues.set(intKeyLongValue.getKey(), intKeyLongValue.getValue());\n                    }\n\n                    thermodynamicValueMatrix.put(id, axisYValues);\n                }\n\n                // try to add default values when there is no data in that time bucket.\n                ids.forEach(id -> {\n                    if (thermodynamicValueMatrix.containsKey(id)) {\n                        thermodynamicValueCollection.add(thermodynamicValueMatrix.get(id));\n                    } else {\n                        thermodynamicValueCollection.add(new ArrayList<>());\n                    }\n                });\n            }\n\n            thermodynamic.fromMatrixData(thermodynamicValueCollection, numOfSteps);\n            thermodynamic.setAxisYStep(axisYStep);\n\n            return thermodynamic;\n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2019-15557",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "@SneakyThrows\n    public void migrate(String tenantKey) {\n        final StopWatch stopWatch = createStarted();\n        try {\n            log.info(\"START - SETUP:CreateTenant:liquibase tenantKey: {}\", tenantKey);\n            SpringLiquibase liquibase = new SpringLiquibase();\n            liquibase.setResourceLoader(resourceLoader);\n            liquibase.setDataSource(dataSource);\n            liquibase.setChangeLog(CHANGE_LOG_PATH);\n            liquibase.setContexts(liquibaseProperties.getContexts());\n            liquibase.setDefaultSchema(tenantKey);\n            liquibase.setDropFirst(liquibaseProperties.isDropFirst());\n            liquibase.setChangeLogParameters(DatabaseUtil.defaultParams(tenantKey));\n            liquibase.setShouldRun(true);\n            liquibase.afterPropertiesSet();\n            log.info(\"STOP  - SETUP:CreateTenant:liquibase tenantKey: {}, result: OK, time = {} ms\", tenantKey,\n                stopWatch.getTime());\n        } catch (Exception e) {\n            log.info(\"STOP  - SETUP:CreateTenant:liquibase tenantKey: {}, result: FAIL, error: {}, time = {} ms\",\n                tenantKey, e.getMessage(), stopWatch.getTime());\n            throw e;\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2014-125075",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "public void addContact(String firstname, String surname, String email, String user) throws SQLException {\n        PreparedStatement newStudent = conn.prepareStatement(\"INSERT INTO \" +\n                \"contactinfo (forename, familyname, emailaddress, contactemailaddress) VALUES ('\" + firstname + \"', '\" + surname + \"', '\" + email + \"', '\" + user + \"')\");\n        newStudent.execute();\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2019-15569",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "public Query build(MetaData metadata, Map<String, String> params, boolean isCountQuery) {\n        final List<Criterion> criteria = criterionFactory.build(metadata, params);\n        \n        String queryToFormat = isCountQuery ? MAIN_COUNT_QUERY : MAIN_QUERY;\n        String whereClausePart = secure(toClauses(criteria), metadata);\n        String sortDirectionPart = metadata.getSortDirection().orElse(SORT_ASCENDING).toUpperCase();\n        \n        String queryString = String.format(queryToFormat, whereClausePart, sortDirectionPart);\n\n        Query query;\n        if (isCountQuery) {\n            query = entityManager.createNativeQuery(queryString);\n        } else {\n            query = entityManager.createNativeQuery(queryString, CaseDetailsEntity.class);\n        }\n        addParameters(query, criteria);\n        return query;\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-41887",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection)\n            throws DatabaseServiceException {\n        try {\n\n            // logger.info(\"connection::{}, forceNewConnection: {}\", connection, forceNewConnection);\n\n            if (connection != null && !forceNewConnection) {\n                // logger.info(\"connection closed::{}\", connection.isClosed());\n                if (!connection.isClosed()) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Returning existing connection::{}\", connection);\n                    }\n                    return connection;\n                }\n            }\n\n            Class.forName(type.getClassPath());\n            DriverManager.setLoginTimeout(10);\n            String dbURL = getDatabaseUrl(databaseConfiguration);\n            connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(),\n                    databaseConfiguration.getDatabasePassword());\n\n            logger.debug(\"*** Acquired New  connection for ::{} **** \", dbURL);\n\n            return connection;\n\n        } catch (ClassNotFoundException e) {\n            logger.error(\"Jdbc Driver not found\", e);\n            throw new DatabaseServiceException(e.getMessage());\n        } catch (SQLException e) {\n            logger.error(\"SQLException::Couldn't get a Connection!\", e);\n            throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2020-13921",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "@Override\n    public TraceBrief queryBasicTraces(long startSecondTB,\n                                       long endSecondTB,\n                                       long minDuration,\n                                       long maxDuration,\n                                       String endpointName,\n                                       String serviceId,\n                                       String serviceInstanceId,\n                                       String endpointId,\n                                       String traceId,\n                                       int limit,\n                                       int from,\n                                       TraceState traceState,\n                                       QueryOrder queryOrder) throws IOException {\n        StringBuilder sql = new StringBuilder();\n        List<Object> parameters = new ArrayList<>(10);\n\n        sql.append(\"from \").append(SegmentRecord.INDEX_NAME).append(\" where \");\n        sql.append(\" 1=1 \");\n        if (startSecondTB != 0 && endSecondTB != 0) {\n            sql.append(\" and \").append(SegmentRecord.TIME_BUCKET).append(\" >= ?\");\n            parameters.add(startSecondTB);\n            sql.append(\" and \").append(SegmentRecord.TIME_BUCKET).append(\" <= ?\");\n            parameters.add(endSecondTB);\n        }\n        if (minDuration != 0 || maxDuration != 0) {\n            if (minDuration != 0) {\n                sql.append(\" and \").append(SegmentRecord.LATENCY).append(\" >= ?\");\n                parameters.add(minDuration);\n            }\n            if (maxDuration != 0) {\n                sql.append(\" and \").append(SegmentRecord.LATENCY).append(\" <= ?\");\n                parameters.add(maxDuration);\n            }\n        }\n        if (!Strings.isNullOrEmpty(endpointName)) {\n            sql.append(\" and \").append(SegmentRecord.ENDPOINT_NAME).append(\" like '%\" + endpointName + \"%'\");\n        }\n        if (StringUtil.isNotEmpty(serviceId)) {\n            sql.append(\" and \").append(SegmentRecord.SERVICE_ID).append(\" = ?\");\n            parameters.add(serviceId);\n        }\n        if (StringUtil.isNotEmpty(serviceInstanceId)) {\n            sql.append(\" and \").append(SegmentRecord.SERVICE_INSTANCE_ID).append(\" = ?\");\n            parameters.add(serviceInstanceId);\n        }\n        if (!Strings.isNullOrEmpty(endpointId)) {\n            sql.append(\" and \").append(SegmentRecord.ENDPOINT_ID).append(\" = ?\");\n            parameters.add(endpointId);\n        }\n        if (!Strings.isNullOrEmpty(traceId)) {\n            sql.append(\" and \").append(SegmentRecord.TRACE_ID).append(\" = ?\");\n            parameters.add(traceId);\n        }\n        switch (traceState) {\n            case ERROR:\n                sql.append(\" and \").append(SegmentRecord.IS_ERROR).append(\" = \").append(BooleanUtils.TRUE);\n                break;\n            case SUCCESS:\n                sql.append(\" and \").append(SegmentRecord.IS_ERROR).append(\" = \").append(BooleanUtils.FALSE);\n                break;\n        }\n        switch (queryOrder) {\n            case BY_START_TIME:\n                sql.append(\" order by \").append(SegmentRecord.START_TIME).append(\" \").append(SortOrder.DESC);\n                break;\n            case BY_DURATION:\n                sql.append(\" order by \").append(SegmentRecord.LATENCY).append(\" \").append(SortOrder.DESC);\n                break;\n        }\n\n        TraceBrief traceBrief = new TraceBrief();\n        try (Connection connection = h2Client.getConnection()) {\n\n            try (ResultSet resultSet = h2Client.executeQuery(connection, buildCountStatement(sql.toString()), parameters\n                .toArray(new Object[0]))) {\n                while (resultSet.next()) {\n                    traceBrief.setTotal(resultSet.getInt(\"total\"));\n                }\n            }\n\n            buildLimit(sql, from, limit);\n\n            try (ResultSet resultSet = h2Client.executeQuery(\n                connection, \"select * \" + sql.toString(), parameters.toArray(new Object[0]))) {\n                while (resultSet.next()) {\n                    BasicTrace basicTrace = new BasicTrace();\n\n                    basicTrace.setSegmentId(resultSet.getString(SegmentRecord.SEGMENT_ID));\n                    basicTrace.setStart(resultSet.getString(SegmentRecord.START_TIME));\n                    basicTrace.getEndpointNames().add(resultSet.getString(SegmentRecord.ENDPOINT_NAME));\n                    basicTrace.setDuration(resultSet.getInt(SegmentRecord.LATENCY));\n                    basicTrace.setError(BooleanUtils.valueToBoolean(resultSet.getInt(SegmentRecord.IS_ERROR)));\n                    String traceIds = resultSet.getString(SegmentRecord.TRACE_ID);\n                    basicTrace.getTraceIds().add(traceIds);\n                    traceBrief.getTraces().add(basicTrace);\n                }\n            }\n        } catch (SQLException e) {\n            throw new IOException(e);\n        }\n\n        return traceBrief;\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-41886",
        "cwe_ids": [
            "CWE-89"
        ],
        "func_before": "public Connection getConnection(DatabaseConfiguration databaseConfiguration, boolean forceNewConnection)\n            throws DatabaseServiceException {\n        try {\n\n            if (connection != null && !forceNewConnection) {\n                // logger.info(\"connection closed::{}\", connection.isClosed());\n                if (!connection.isClosed()) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Returning existing connection::{}\", connection);\n                    }\n\n                    return connection;\n                }\n            }\n            String dbURL = getDatabaseUrl(databaseConfiguration);\n            Class.forName(type.getClassPath());\n\n            // logger.info(\"*** type.getClassPath() ::{}, {}**** \", type.getClassPath());\n\n            DriverManager.setLoginTimeout(10);\n\n            connection = DriverManager.getConnection(dbURL, databaseConfiguration.getDatabaseUser(),\n                    databaseConfiguration.getDatabasePassword());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"*** Acquired New  connection for ::{} **** \", dbURL);\n            }\n\n            return connection;\n\n        } catch (ClassNotFoundException e) {\n            logger.error(\"Jdbc Driver not found\", e);\n            throw new DatabaseServiceException(e.getMessage());\n        } catch (SQLException e) {\n            logger.error(\"SQLException::Couldn't get a Connection!\", e);\n            throw new DatabaseServiceException(true, e.getSQLState(), e.getErrorCode(), e.getMessage());\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2021-43287",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "@RequestMapping(value = \"/add-on/business-continuity/admin/dashboard\", method = RequestMethod.GET)\n    @ResponseBody\n    public String dashboard(HttpServletRequest request, HttpServletResponse response) {\n        return renderAfterAuthentication(request, response, dashboardHTML);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-50719",
        "cwe_ids": [
            "CWE-312",
            "CWE-200"
        ],
        "func_before": "private void setStaticListPropertyValue(SolrInputDocument solrDocument, BaseProperty<EntityReference> property,\n        StaticListClass propertyClass, Locale locale)\n    {\n        // The list of known values specified in the XClass.\n        Map<String, ListItem> knownValues = propertyClass.getMap(this.xcontextProvider.get());\n        Object propertyValue = property.getValue();\n        // When multiple selection is on the value is a list. Otherwise, for single selection, the value is a string.\n        List<?> rawValues = propertyValue instanceof List ? (List<?>) propertyValue : Arrays.asList(propertyValue);\n        for (Object rawValue : rawValues) {\n            // Avoid indexing null values.\n            if (rawValue != null) {\n                // Index the raw value that is saved in the database. This is most probably a string so we'll be able to\n                // perform exact matches on this value.\n                setPropertyValue(solrDocument, property, new TypedValue(rawValue), locale);\n                ListItem valueInfo = knownValues.get(rawValue);\n                if (valueInfo != null && valueInfo.getValue() != null && !valueInfo.getValue().equals(rawValue)) {\n                    // Index the display value as text (based on the given locale). This is the text seen by the user\n                    // when he edits the static list property. This text is specified on the XClass (but can be\n                    // overwritten by translations!).\n                    setPropertyValue(solrDocument, property, new TypedValue(valueInfo.getValue(), TypedValue.TEXT),\n                        locale);\n                }\n            }\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2013-6447",
        "cwe_ids": [
            "CWE-264",
            "CWE-200"
        ],
        "func_before": "public void handle(HttpServletRequest request, final HttpServletResponse response)\n      throws Exception\n  {\n      // We're sending an XML response, so set the response content type to text/xml\n      response.setContentType(\"text/xml\");\n      \n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n      \n      byte[] buffer = new byte[256];\n      int read = request.getInputStream().read(buffer);\n      while (read != -1)\n      {\n         out.write(buffer, 0, read);\n         read = request.getInputStream().read(buffer);\n      }\n      \n      String requestData = new String(out.toByteArray());\n      log.debug(\"Processing remote request: \" + requestData);\n      \n      // Parse the incoming request as XML\n      SAXReader xmlReader = new SAXReader();\n      Document doc = xmlReader.read( new StringReader(requestData) );\n      final Element env = doc.getRootElement();\n      final RequestContext ctx = unmarshalContext(env);\n\n      // TODO - we really want to extract the page context from our request\n      RemotingLifecycle.restorePageContext();\n\n      new ContextualHttpServletRequest(request)\n      {\n         @Override\n         public void process() throws Exception\n         {\n            // Extract the calls from the request            \n            List<Call> calls = unmarshalCalls(env);\n\n            // Execute each of the calls\n            for (Call call : calls) \n            {\n               call.execute();\n            }               \n\n            // Store the conversation ID in the outgoing context\n            ctx.setConversationId( Manager.instance().getCurrentConversationId() );               \n            \n            // Package up the response\n            marshalResponse(calls, ctx, response.getOutputStream());               \n         }\n         \n         @Override\n         protected void restoreConversationId()\n         {\n            ConversationPropagation.instance().setConversationId( ctx.getConversationId() );\n         }\n         \n         @Override\n         protected void handleConversationPropagation() {}\n         \n      }.run();\n      \n  }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2016-2500",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "final void removeLruProcessLocked(ProcessRecord app) {\n        int lrui = mLruProcesses.lastIndexOf(app);\n        if (lrui >= 0) {\n            if (!app.killed) {\n                Slog.wtfStack(TAG, \"Removing process that hasn't been killed: \" + app);\n                Process.killProcessQuiet(app.pid);\n                killProcessGroup(app.info.uid, app.pid);\n            }\n            if (lrui <= mLruProcessActivityStart) {\n                mLruProcessActivityStart--;\n            }\n            if (lrui <= mLruProcessServiceStart) {\n                mLruProcessServiceStart--;\n            }\n            mLruProcesses.remove(lrui);\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2016-3759",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "private void dumpInternal(PrintWriter pw) {\n        synchronized (mQueueLock) {\n            pw.println(\"Backup Manager is \" + (mEnabled ? \"enabled\" : \"disabled\")\n                    + \" / \" + (!mProvisioned ? \"not \" : \"\") + \"provisioned / \"\n                    + (this.mPendingInits.size() == 0 ? \"not \" : \"\") + \"pending init\");\n            pw.println(\"Auto-restore is \" + (mAutoRestore ? \"enabled\" : \"disabled\"));\n            if (mBackupRunning) pw.println(\"Backup currently running\");\n            pw.println(\"Last backup pass started: \" + mLastBackupPass\n                    + \" (now = \" + System.currentTimeMillis() + ')');\n            pw.println(\"  next scheduled: \" + KeyValueBackupJob.nextScheduled());\n\n            pw.println(\"Available transports:\");\n            final String[] transports = listAllTransports();\n            if (transports != null) {\n                for (String t : listAllTransports()) {\n                    pw.println((t.equals(mCurrentTransport) ? \"  * \" : \"    \") + t);\n                    try {\n                        IBackupTransport transport = getTransport(t);\n                        File dir = new File(mBaseStateDir, transport.transportDirName());\n                        pw.println(\"       destination: \" + transport.currentDestinationString());\n                        pw.println(\"       intent: \" + transport.configurationIntent());\n                        for (File f : dir.listFiles()) {\n                            pw.println(\"       \" + f.getName() + \" - \" + f.length() + \" state bytes\");\n                        }\n                    } catch (Exception e) {\n                        Slog.e(TAG, \"Error in transport\", e);\n                        pw.println(\"        Error: \" + e);\n                    }\n                }\n            }\n\n            pw.println(\"Pending init: \" + mPendingInits.size());\n            for (String s : mPendingInits) {\n                pw.println(\"    \" + s);\n            }\n\n            if (DEBUG_BACKUP_TRACE) {\n                synchronized (mBackupTrace) {\n                    if (!mBackupTrace.isEmpty()) {\n                        pw.println(\"Most recent backup trace:\");\n                        for (String s : mBackupTrace) {\n                            pw.println(\"   \" + s);\n                        }\n                    }\n                }\n            }\n\n            pw.print(\"Ancestral: \"); pw.println(Long.toHexString(mAncestralToken));\n            pw.print(\"Current:   \"); pw.println(Long.toHexString(mCurrentToken));\n\n            int N = mBackupParticipants.size();\n            pw.println(\"Participants:\");\n            for (int i=0; i<N; i++) {\n                int uid = mBackupParticipants.keyAt(i);\n                pw.print(\"  uid: \");\n                pw.println(uid);\n                HashSet<String> participants = mBackupParticipants.valueAt(i);\n                for (String app: participants) {\n                    pw.println(\"    \" + app);\n                }\n            }\n\n            pw.println(\"Ancestral packages: \"\n                    + (mAncestralPackages == null ? \"none\" : mAncestralPackages.size()));\n            if (mAncestralPackages != null) {\n                for (String pkg : mAncestralPackages) {\n                    pw.println(\"    \" + pkg);\n                }\n            }\n\n            pw.println(\"Ever backed up: \" + mEverStoredApps.size());\n            for (String pkg : mEverStoredApps) {\n                pw.println(\"    \" + pkg);\n            }\n\n            pw.println(\"Pending key/value backup: \" + mPendingBackups.size());\n            for (BackupRequest req : mPendingBackups.values()) {\n                pw.println(\"    \" + req);\n            }\n\n            pw.println(\"Full backup queue:\" + mFullBackupQueue.size());\n            for (FullBackupEntry entry : mFullBackupQueue) {\n                pw.print(\"    \"); pw.print(entry.lastBackup);\n                pw.print(\" : \"); pw.println(entry.packageName);\n            }\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2022-41926",
        "cwe_ids": [
            "CWE-732",
            "CWE-200"
        ],
        "func_before": "@RequiresApi(api = Build.VERSION_CODES.O)\n    @Override\n    public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode, Configuration newConfig) {\n        super.onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);\n        Log.d(TAG, \"onPictureInPictureModeChanged\");\n        Log.d(TAG, \"isInPictureInPictureMode= \" + isInPictureInPictureMode);\n        isInPipMode = isInPictureInPictureMode;\n        if (isInPictureInPictureMode) {\n            mReceiver =\n                new BroadcastReceiver() {\n                    @Override\n                    public void onReceive(Context context, Intent intent) {\n                        if (intent == null || !MICROPHONE_PIP_INTENT_NAME.equals(intent.getAction())) {\n                            return;\n                        }\n\n                        final int action = intent.getIntExtra(MICROPHONE_PIP_INTENT_EXTRA_ACTION, 0);\n                        switch (action) {\n                            case MICROPHONE_PIP_REQUEST_MUTE:\n                            case MICROPHONE_PIP_REQUEST_UNMUTE:\n                                onMicrophoneClick();\n                                break;\n                        }\n                    }\n                };\n            registerReceiver(mReceiver, new IntentFilter(MICROPHONE_PIP_INTENT_NAME));\n\n            updateUiForPipMode();\n        } else {\n            unregisterReceiver(mReceiver);\n            mReceiver = null;\n\n            updateUiForNormalMode();\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-25499",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "public List<PendingJavaScriptInvocation> dumpPendingJavaScriptInvocations() {\n        pendingTitleUpdateCanceler = null;\n\n        if (pendingJsInvocations.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<PendingJavaScriptInvocation> currentList = getPendingJavaScriptInvocations()\n                .peek(PendingJavaScriptInvocation::setSentToBrowser)\n                .collect(Collectors.toList());\n\n        pendingJsInvocations = new ArrayList<>();\n\n        return currentList;\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-25500",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "static void invokeMethod(Component instance, Class<?> clazz,\n            String methodName, JsonArray args, int promiseId, boolean inert) {\n        assert instance != null;\n        Optional<Method> method = findMethod(instance, clazz, methodName);\n        if (method.isPresent()) {\n            invokeMethod(instance, method.get(), args, promiseId, inert);\n        } else if (instance instanceof Composite) {\n            Component compositeContent = ((Composite<?>) instance).getContent();\n            invokeMethod(compositeContent, compositeContent.getClass(),\n                    methodName, args, promiseId, inert);\n        } else {\n            String msg = String.format(\"Neither class '%s' \"\n                    + \"nor its super classes declare event handler method '%s'\",\n                    instance.getClass().getName(), methodName);\n            throw new IllegalStateException(msg);\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2016-2425",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "private long handleAttachmentUrisFromIntent(List<Uri> uris) {\n        ArrayList<Attachment> attachments = Lists.newArrayList();\n        for (Uri uri : uris) {\n            try {\n                if (uri != null) {\n                    if (\"file\".equals(uri.getScheme())) {\n                        final File f = new File(uri.getPath());\n                        // We should not be attaching any files from the data directory UNLESS\n                        // the data directory is part of the calling process.\n                        final String filePath = f.getCanonicalPath();\n                        if (filePath.startsWith(DATA_DIRECTORY_ROOT)) {\n                            final String callingPackage = getCallingPackage();\n                            if (callingPackage == null) {\n                                showErrorToast(getString(R.string.attachment_permission_denied));\n                                continue;\n                            }\n\n                            // So it looks like the data directory are usually /data/data, but\n                            // DATA_DIRECTORY_ROOT is only /data.. so let's check for both\n                            final String pathWithoutRoot;\n                            // We add 1 to the length for the additional / before the package name.\n                            if (filePath.startsWith(ALTERNATE_DATA_DIRECTORY_ROOT)) {\n                                pathWithoutRoot = filePath.substring(\n                                        ALTERNATE_DATA_DIRECTORY_ROOT.length() + 1);\n                            } else {\n                                pathWithoutRoot = filePath.substring(\n                                        DATA_DIRECTORY_ROOT.length() + 1);\n                            }\n\n                            // If we are trying to access a data package that's not part of the\n                            // calling package, show error toast and ignore this attachment.\n                            if (!pathWithoutRoot.startsWith(callingPackage)) {\n                                showErrorToast(getString(R.string.attachment_permission_denied));\n                                continue;\n                            }\n                        }\n                    }\n                    if (!handleSpecialAttachmentUri(uri)) {\n                        final Attachment a = mAttachmentsView.generateLocalAttachment(uri);\n                        attachments.add(a);\n\n                        Analytics.getInstance().sendEvent(\"send_intent_attachment\",\n                                Utils.normalizeMimeType(a.getContentType()), null, a.size);\n                    }\n                }\n            } catch (AttachmentFailureException e) {\n                LogUtils.e(LOG_TAG, e, \"Error adding attachment\");\n                showAttachmentTooBigToast(e.getErrorRes());\n            } catch (IOException | SecurityException e) {\n                LogUtils.e(LOG_TAG, e, \"Error adding attachment\");\n                showErrorToast(getString(R.string.attachment_permission_denied));\n            }\n        }\n        return addAttachments(attachments);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2021-3503",
        "cwe_ids": [
            "CWE-200"
        ],
        "func_before": "private ModelNode readAttributeValue(PathAddress address, String attributeName) {\n        final ModelNode readAttributeOp = new ModelNode();\n        readAttributeOp.get(OP).set(READ_ATTRIBUTE_OPERATION);\n        readAttributeOp.get(OP_ADDR).set(address.toModelNode());\n        readAttributeOp.get(ModelDescriptionConstants.INCLUDE_UNDEFINED_METRIC_VALUES).set(false);\n        readAttributeOp.get(NAME).set(attributeName);\n        ModelNode response = modelControllerClient.execute(readAttributeOp);\n        String error = getFailureDescription(response);\n        if (error != null) {\n            // [WFLY-11933] if the value can not be read if the management resource is not accessible due to RBAC,\n            // it is logged it at a lower level.\n            if (error.contains(\"WFLYCTL0216\")) {\n                LOGGER.debugf(\"Unable to read attribute %s: %s.\", attributeName, error);\n            } else{\n                LOGGER.unableToReadAttribute(attributeName, address, error);\n            }\n            return new ModelNode(ModelType.UNDEFINED);\n        }\n        return  response.get(RESULT);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-35925",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "@Override\n    public void run() {\n        FaweTimer timer = Fawe.instance().getTimer();\n        if (cancelled.get()) {\n            return;\n        }\n        if (update.isEmpty()) {\n            TaskManager.taskManager().laterAsync(this, 1);\n            return;\n        }\n        Iterator<Map.Entry<UUID, MutablePair<World, Set<BlockVector2>>>> plrIter = update.entrySet().iterator();\n        while (timer.getTPS() > 18 && plrIter.hasNext()) {\n            if (cancelled.get()) {\n                return;\n            }\n            Map.Entry<UUID, MutablePair<World, Set<BlockVector2>>> entry = plrIter.next();\n            MutablePair<World, Set<BlockVector2>> pair = entry.getValue();\n            World world = pair.getKey();\n            Set<BlockVector2> chunks = pair.getValue();\n            if (chunks != null) {\n                Iterator<BlockVector2> chunksIter = chunks.iterator();\n                while (chunksIter.hasNext() && pair.getValue() == chunks) { // Ensure the queued load is still valid\n                    BlockVector2 chunk = chunksIter.next();\n                    queueLoad(world, chunk);\n                }\n            }\n            plrIter.remove();\n        }\n        if (cancelled.get()) {\n            return;\n        }\n        TaskManager.taskManager().laterAsync(this, 20);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2022-21700",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> context,\n            ReturnType returnTypeObject,\n            CacheOperation cacheOperation,\n            AnnotationValue<Cacheable> cacheable) {\n        AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n        CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n        Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n        Object key = keyGenerator.generateKey(context, params);\n        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n\n        Maybe<Object> maybe = Maybe.create(emitter -> {\n            asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {\n               if (throwable != null) {\n                   if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                       emitter.onError(throwable);\n                   } else {\n                       emitter.onComplete();\n                   }\n                   emitter.onError(throwable);\n               } else if (opt.isPresent()) {\n                   if (LOG.isDebugEnabled()) {\n                       LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                   }\n                   emitter.onSuccess(opt.get());\n               } else {\n                   emitter.onComplete();\n               }\n            });\n        });\n\n        return maybe.isEmpty().flatMapPublisher(empty -> {\n            if (empty) {\n               return Publishers.convertPublisher(\n                       context.proceed(), Flowable.class)\n                       .flatMap(o -> {\n                           return Single.create(emitter -> {\n                               asyncCache.put(key, o).whenComplete((aBoolean, throwable1) -> {\n                                   if (throwable1 == null) {\n                                       emitter.onSuccess(o);\n                                   } else {\n                                       if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable1))) {\n\n                                           emitter.onError(throwable1);\n                                       } else {\n                                           emitter.onSuccess(o);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return maybe.toFlowable();\n            }\n        });\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-35925",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "@Override\n    public boolean clearContainerBlockContents(BlockVector3 pt) {\n        checkNotNull(pt);\n        BukkitImplAdapter adapter = WorldEditPlugin.getInstance().getBukkitImplAdapter();\n        if (adapter != null) {\n            try {\n                return adapter.clearContainerBlockContents(getWorld(), pt);\n            } catch (Exception ignored) {\n            }\n        }\n        if (!getBlock(pt).getBlockType().getMaterial().hasContainer()) {\n            return false;\n        }\n\n        Block block = getWorld().getBlockAt(pt.getBlockX(), pt.getBlockY(), pt.getBlockZ());\n        BlockState state = PaperLib.getBlockState(block, false).getState();\n        if (!(state instanceof InventoryHolder)) {\n            return false;\n        }\n\n        TaskManager.taskManager().sync(() -> {\n            InventoryHolder chest = (InventoryHolder) state;\n            Inventory inven = chest.getInventory();\n            if (chest instanceof Chest) {\n                inven = ((Chest) chest).getBlockInventory();\n            }\n            inven.clear();\n            return null;\n        });\n        return true;\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-46120",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "@Override\n    public FrameHandler create(Address addr, String connectionName) throws IOException {\n        int portNumber = ConnectionFactory.portOrDefault(addr.getPort(), ssl);\n\n        SSLEngine sslEngine = null;\n        SocketChannel channel = null;\n\n        try {\n            if (ssl) {\n                SSLContext sslContext = sslContextFactory.create(connectionName);\n                sslEngine = sslContext.createSSLEngine(addr.getHost(), portNumber);\n                sslEngine.setUseClientMode(true);\n                if (nioParams.getSslEngineConfigurator() != null) {\n                    nioParams.getSslEngineConfigurator().configure(sslEngine);\n                }\n            }\n\n            SocketAddress address = addr.toInetSocketAddress(portNumber);\n            // No Sonar: the channel is closed in case of error and it cannot\n            // be closed here because it's part of the state of the connection\n            // to be returned.\n            channel = SocketChannel.open(); //NOSONAR\n            channel.configureBlocking(true);\n            if(nioParams.getSocketChannelConfigurator() != null) {\n                nioParams.getSocketChannelConfigurator().configure(channel);\n            }\n\n            channel.socket().connect(address, this.connectionTimeout);\n\n\n            if (ssl) {\n                int initialSoTimeout = channel.socket().getSoTimeout();\n                channel.socket().setSoTimeout(this.connectionTimeout);\n                sslEngine.beginHandshake();\n                try {\n                    ReadableByteChannel wrappedReadChannel = Channels.newChannel(\n                        channel.socket().getInputStream());\n                    WritableByteChannel wrappedWriteChannel = Channels.newChannel(\n                        channel.socket().getOutputStream());\n                    boolean handshake = SslEngineHelper.doHandshake(\n                        wrappedWriteChannel, wrappedReadChannel, sslEngine);\n                    if (!handshake) {\n                        LOGGER.error(\"TLS connection failed\");\n                        throw new SSLException(\"TLS handshake failed\");\n                    }\n                    channel.socket().setSoTimeout(initialSoTimeout);\n                } catch (SSLHandshakeException e) {\n                    LOGGER.error(\"TLS connection failed: {}\", e.getMessage());\n                    throw e;\n                }\n                TlsUtils.logPeerCertificateInfo(sslEngine.getSession());\n            }\n\n            channel.configureBlocking(false);\n\n            // lock\n            stateLock.lock();\n            NioLoopContext nioLoopContext = null;\n            try {\n                long modulo = globalConnectionCount.getAndIncrement() % nioParams.getNbIoThreads();\n                nioLoopContext = nioLoopContexts.get((int) modulo);\n                nioLoopContext.initStateIfNecessary();\n                SocketChannelFrameHandlerState state = new SocketChannelFrameHandlerState(\n                    channel,\n                    nioLoopContext,\n                    nioParams,\n                    sslEngine\n                );\n                state.startReading();\n                SocketChannelFrameHandler frameHandler = new SocketChannelFrameHandler(state);\n                return frameHandler;\n            } finally {\n                stateLock.unlock();\n            }\n\n\n        } catch(IOException e) {\n            try {\n                if(sslEngine != null && channel != null) {\n                    SslEngineHelper.close(channel, sslEngine);\n                }\n                if (channel != null) {\n                    channel.close();\n                }\n            } catch(IOException closingException) {\n                // ignore\n            }\n            throw e;\n        }\n\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2021-32053",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "public boolean ensureSearchEntityLoaded() {\n\t\tif (mySearchEntity == null) {\n\t\t\tOptional<Search> searchOpt = mySearchCacheSvc.fetchByUuid(myUuid);\n\t\t\tif (!searchOpt.isPresent()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsetSearchEntity(searchOpt.get());\n\n\t\t\tourLog.trace(\"Retrieved search with version {} and total {}\", mySearchEntity.getVersion(), mySearchEntity.getTotalCount());\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (mySearchEntity.getSearchType() == SearchTypeEnum.HISTORY) {\n\t\t\tif (mySearchEntity.getTotalCount() == null) {\n\t\t\t\tnew TransactionTemplate(myTxManager).executeWithoutResult(t->{\n\t\t\t\t\tHistoryBuilder historyBuilder = myHistoryBuilderFactory.newHistoryBuilder(mySearchEntity.getResourceType(), mySearchEntity.getResourceId(), mySearchEntity.getLastUpdatedLow(), mySearchEntity.getLastUpdatedHigh());\n\t\t\t\t\tLong count = historyBuilder.fetchCount(getRequestPartitionId());\n\t\t\t\t\tmySearchEntity.setTotalCount(count.intValue());\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2022-21700",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "default Optional<String> findFirst(CharSequence name) {\n        return getFirst(name, String.class);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-35925",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "@Override\n    public boolean generateTree(TreeGenerator.TreeType type, EditSession editSession, BlockVector3 pt) {\n        //FAWE start - allow tree commands to be undone and obey region restrictions\n        return WorldEditPlugin.getInstance().getBukkitImplAdapter().generateTree(type, editSession, pt, getWorld());\n        //FAWE end\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-21253",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "synchronized boolean readCertificates() {\n        if (metaEntries.isEmpty()) {\n            return false;\n        }\n\n        Iterator<String> it = metaEntries.keySet().iterator();\n        while (it.hasNext()) {\n            String key = it.next();\n            if (key.endsWith(\".DSA\") || key.endsWith(\".RSA\") || key.endsWith(\".EC\")) {\n                verifyCertificate(key);\n                it.remove();\n            }\n        }\n        return true;\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-21253",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "private static VerifiedSigner verify(\n            RandomAccessFile apk,\n            SignatureInfo signatureInfo,\n            boolean doVerifyIntegrity) throws SecurityException, IOException {\n        int signerCount = 0;\n        Map<Integer, byte[]> contentDigests = new ArrayMap<>();\n        List<X509Certificate[]> signerCerts = new ArrayList<>();\n        CertificateFactory certFactory;\n        try {\n            certFactory = CertificateFactory.getInstance(\"X.509\");\n        } catch (CertificateException e) {\n            throw new RuntimeException(\"Failed to obtain X.509 CertificateFactory\", e);\n        }\n        ByteBuffer signers;\n        try {\n            signers = getLengthPrefixedSlice(signatureInfo.signatureBlock);\n        } catch (IOException e) {\n            throw new SecurityException(\"Failed to read list of signers\", e);\n        }\n        while (signers.hasRemaining()) {\n            signerCount++;\n            try {\n                ByteBuffer signer = getLengthPrefixedSlice(signers);\n                X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);\n                signerCerts.add(certs);\n            } catch (IOException | BufferUnderflowException | SecurityException e) {\n                throw new SecurityException(\n                        \"Failed to parse/verify signer #\" + signerCount + \" block\",\n                        e);\n            }\n        }\n\n        if (signerCount < 1) {\n            throw new SecurityException(\"No signers found\");\n        }\n\n        if (contentDigests.isEmpty()) {\n            throw new SecurityException(\"No content digests found\");\n        }\n\n        if (doVerifyIntegrity) {\n            ApkSigningBlockUtils.verifyIntegrity(contentDigests, apk, signatureInfo);\n        }\n\n        byte[] verityRootHash = null;\n        if (contentDigests.containsKey(CONTENT_DIGEST_VERITY_CHUNKED_SHA256)) {\n            byte[] verityDigest = contentDigests.get(CONTENT_DIGEST_VERITY_CHUNKED_SHA256);\n            verityRootHash = ApkSigningBlockUtils.parseVerityDigestAndVerifySourceLength(\n                    verityDigest, apk.getChannel().size(), signatureInfo);\n        }\n\n        return new VerifiedSigner(\n                signerCerts.toArray(new X509Certificate[signerCerts.size()][]),\n                verityRootHash, contentDigests);\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-21253",
        "cwe_ids": [
            "CWE-400"
        ],
        "func_before": "private static void verify(\n                DataSource apk,\n                long cdStartOffset,\n                List<CentralDirectoryRecord> cdRecords,\n                Set<String> cdEntryNames,\n                Map<Integer, String> supportedApkSigSchemeNames,\n                Set<Integer> foundApkSigSchemeIds,\n                int minSdkVersion,\n                int maxSdkVersion,\n                Result result) throws ApkFormatException, IOException, NoSuchAlgorithmException {\n\n            // Find JAR manifest and signature block files.\n            CentralDirectoryRecord manifestEntry = null;\n            Map<String, CentralDirectoryRecord> sigFileEntries = new HashMap<>(1);\n            List<CentralDirectoryRecord> sigBlockEntries = new ArrayList<>(1);\n            for (CentralDirectoryRecord cdRecord : cdRecords) {\n                String entryName = cdRecord.getName();\n                if (!entryName.startsWith(\"META-INF/\")) {\n                    continue;\n                }\n                if ((manifestEntry == null) && (V1SchemeConstants.MANIFEST_ENTRY_NAME.equals(\n                        entryName))) {\n                    manifestEntry = cdRecord;\n                    continue;\n                }\n                if (entryName.endsWith(\".SF\")) {\n                    sigFileEntries.put(entryName, cdRecord);\n                    continue;\n                }\n                if ((entryName.endsWith(\".RSA\"))\n                        || (entryName.endsWith(\".DSA\"))\n                        || (entryName.endsWith(\".EC\"))) {\n                    sigBlockEntries.add(cdRecord);\n                    continue;\n                }\n            }\n            if (manifestEntry == null) {\n                result.addError(Issue.JAR_SIG_NO_MANIFEST);\n                return;\n            }\n\n            // Parse the JAR manifest and check that all JAR entries it references exist in the APK.\n            byte[] manifestBytes;\n            try {\n                manifestBytes =\n                        LocalFileRecord.getUncompressedData(apk, manifestEntry, cdStartOffset);\n            } catch (ZipFormatException e) {\n                throw new ApkFormatException(\"Malformed ZIP entry: \" + manifestEntry.getName(), e);\n            }\n\n            Pair<ManifestParser.Section, Map<String, ManifestParser.Section>> manifestSections =\n                    parseManifest(manifestBytes, cdEntryNames, result);\n\n            if (result.containsErrors()) {\n                return;\n            }\n\n            ManifestParser.Section manifestMainSection = manifestSections.getFirst();\n            Map<String, ManifestParser.Section> entryNameToManifestSection =\n                    manifestSections.getSecond();\n\n            // STATE OF AFFAIRS:\n            // * All JAR entries listed in JAR manifest are present in the APK.\n\n            // Identify signers\n            List<Signer> signers = new ArrayList<>(sigBlockEntries.size());\n            for (CentralDirectoryRecord sigBlockEntry : sigBlockEntries) {\n                String sigBlockEntryName = sigBlockEntry.getName();\n                int extensionDelimiterIndex = sigBlockEntryName.lastIndexOf('.');\n                if (extensionDelimiterIndex == -1) {\n                    throw new RuntimeException(\n                            \"Signature block file name does not contain extension: \"\n                                    + sigBlockEntryName);\n                }\n                String sigFileEntryName =\n                        sigBlockEntryName.substring(0, extensionDelimiterIndex) + \".SF\";\n                CentralDirectoryRecord sigFileEntry = sigFileEntries.get(sigFileEntryName);\n                if (sigFileEntry == null) {\n                    result.addWarning(\n                            Issue.JAR_SIG_MISSING_FILE, sigBlockEntryName, sigFileEntryName);\n                    continue;\n                }\n                String signerName = sigBlockEntryName.substring(\"META-INF/\".length());\n                Result.SignerInfo signerInfo =\n                        new Result.SignerInfo(\n                                signerName, sigBlockEntryName, sigFileEntry.getName());\n                Signer signer = new Signer(signerName, sigBlockEntry, sigFileEntry, signerInfo);\n                signers.add(signer);\n            }\n            if (signers.isEmpty()) {\n                result.addError(Issue.JAR_SIG_NO_SIGNATURES);\n                return;\n            }\n\n            // Verify each signer's signature block file .(RSA|DSA|EC) against the corresponding\n            // signature file .SF. Any error encountered for any signer terminates verification, to\n            // mimic Android's behavior.\n            for (Signer signer : signers) {\n                signer.verifySigBlockAgainstSigFile(\n                        apk, cdStartOffset, minSdkVersion, maxSdkVersion);\n                if (signer.getResult().containsErrors()) {\n                    result.signers.add(signer.getResult());\n                }\n            }\n            if (result.containsErrors()) {\n                return;\n            }\n            // STATE OF AFFAIRS:\n            // * All JAR entries listed in JAR manifest are present in the APK.\n            // * All signature files (.SF) verify against corresponding block files (.RSA|.DSA|.EC).\n\n            // Verify each signer's signature file (.SF) against the JAR manifest.\n            List<Signer> remainingSigners = new ArrayList<>(signers.size());\n            for (Signer signer : signers) {\n                signer.verifySigFileAgainstManifest(\n                        manifestBytes,\n                        manifestMainSection,\n                        entryNameToManifestSection,\n                        supportedApkSigSchemeNames,\n                        foundApkSigSchemeIds,\n                        minSdkVersion,\n                        maxSdkVersion);\n                if (signer.isIgnored()) {\n                    result.ignoredSigners.add(signer.getResult());\n                } else {\n                    if (signer.getResult().containsErrors()) {\n                        result.signers.add(signer.getResult());\n                    } else {\n                        remainingSigners.add(signer);\n                    }\n                }\n            }\n            if (result.containsErrors()) {\n                return;\n            }\n            signers = remainingSigners;\n            if (signers.isEmpty()) {\n                result.addError(Issue.JAR_SIG_NO_SIGNATURES);\n                return;\n            }\n            // STATE OF AFFAIRS:\n            // * All signature files (.SF) verify against corresponding block files (.RSA|.DSA|.EC).\n            // * Contents of all JAR manifest sections listed in .SF files verify against .SF files.\n            // * All JAR entries listed in JAR manifest are present in the APK.\n\n            // Verify data of JAR entries against JAR manifest and .SF files. On Android, an APK's\n            // JAR entry is considered signed by signers associated with an .SF file iff the entry\n            // is mentioned in the .SF file and the entry's digest(s) mentioned in the JAR manifest\n            // match theentry's uncompressed data. Android requires that all such JAR entries are\n            // signed by the same set of signers. This set may be smaller than the set of signers\n            // we've identified so far.\n            Set<Signer> apkSigners =\n                    verifyJarEntriesAgainstManifestAndSigners(\n                            apk,\n                            cdStartOffset,\n                            cdRecords,\n                            entryNameToManifestSection,\n                            signers,\n                            minSdkVersion,\n                            maxSdkVersion,\n                            result);\n            if (result.containsErrors()) {\n                return;\n            }\n            // STATE OF AFFAIRS:\n            // * All signature files (.SF) verify against corresponding block files (.RSA|.DSA|.EC).\n            // * Contents of all JAR manifest sections listed in .SF files verify against .SF files.\n            // * All JAR entries listed in JAR manifest are present in the APK.\n            // * All JAR entries present in the APK and supposed to be covered by JAR signature\n            //   (i.e., reside outside of META-INF/) are covered by signatures from the same set\n            //   of signers.\n\n            // Report any JAR entries which aren't covered by signature.\n            Set<String> signatureEntryNames = new HashSet<>(1 + result.signers.size() * 2);\n            signatureEntryNames.add(manifestEntry.getName());\n            for (Signer signer : apkSigners) {\n                signatureEntryNames.add(signer.getSignatureBlockEntryName());\n                signatureEntryNames.add(signer.getSignatureFileEntryName());\n            }\n            for (CentralDirectoryRecord cdRecord : cdRecords) {\n                String entryName = cdRecord.getName();\n                if ((entryName.startsWith(\"META-INF/\"))\n                        && (!entryName.endsWith(\"/\"))\n                        && (!signatureEntryNames.contains(entryName))) {\n                    result.addWarning(Issue.JAR_SIG_UNPROTECTED_ZIP_ENTRY, entryName);\n                }\n            }\n\n            // Reflect the sets of used signers and ignored signers in the result.\n            for (Signer signer : signers) {\n                if (apkSigners.contains(signer)) {\n                    result.signers.add(signer.getResult());\n                } else {\n                    result.ignoredSigners.add(signer.getResult());\n                }\n            }\n\n            result.verified = true;\n        }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "public FileWithSuffix getFile(String filename, String suffix) throws IOException {\n\t\tfinal int idx = filename.indexOf('~');\n\t\tfinal AFile file;\n\t\tfinal String entry;\n\t\tif (idx == -1) {\n\t\t\tfile = getAFile(filename);\n\t\t\tentry = null;\n\t\t} else {\n\t\t\tfile = getAFile(filename.substring(0, idx));\n\t\t\tentry = filename.substring(idx + 1);\n\t\t}\n\t\tif (isAllowed(file) == false)\n\t\t\treturn FileWithSuffix.none();\n\n\t\treturn new FileWithSuffix(filename, suffix, file, entry);\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2016-3838",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "@Override\n    public void stopLockTaskMode() {\n        final TaskRecord lockTask = mStackSupervisor.getLockedTaskLocked();\n        if (lockTask == null) {\n            // Our work here is done.\n            return;\n        }\n\n        final int callingUid = Binder.getCallingUid();\n        final int lockTaskUid = lockTask.mLockTaskUid;\n        // Ensure the same caller for startLockTaskMode and stopLockTaskMode.\n        // It is possible lockTaskMode was started by the system process because\n        // android:lockTaskMode is set to a locking value in the application manifest instead of\n        // the app calling startLockTaskMode. In this case {@link TaskRecord.mLockTaskUid} will\n        // be 0, so we compare the callingUid to the {@link TaskRecord.effectiveUid} instead.\n        if (getLockTaskModeState() == ActivityManager.LOCK_TASK_MODE_LOCKED &&\n                callingUid != lockTaskUid\n                && (lockTaskUid != 0\n                    || (lockTaskUid == 0 && callingUid != lockTask.effectiveUid))) {\n            throw new SecurityException(\"Invalid uid, expected \" + lockTaskUid\n                    + \" callingUid=\" + callingUid + \" effectiveUid=\" + lockTask.effectiveUid);\n        }\n\n        long ident = Binder.clearCallingIdentity();\n        try {\n            Log.d(TAG, \"stopLockTaskMode\");\n            // Stop lock task\n            synchronized (this) {\n                mStackSupervisor.setLockTaskModeLocked(null, ActivityManager.LOCK_TASK_MODE_NONE,\n                        \"stopLockTask\", true);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(ident);\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2016-3884",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "private void enforcePolicyAccess(String pkg, String method) {\n            if (PackageManager.PERMISSION_GRANTED == getContext().checkCallingPermission(\n                    android.Manifest.permission.MANAGE_NOTIFICATIONS)) {\n                return;\n            }\n            if (!checkPolicyAccess(pkg)) {\n                Slog.w(TAG, \"Notification policy access denied calling \" + method);\n                throw new SecurityException(\"Notification policy access denied\");\n            }\n        }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "public TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\t// ::comment when __CORE__\n\t\tif (OptionFlags.ALLOW_INCLUDE == false)\n\t\t\t// ::done\n\t\t\treturn TValue.fromBoolean(false);\n\t\t// ::comment when __CORE__\n\n\t\tfinal String path = values.get(0).toString();\n\t\treturn TValue.fromBoolean(fileExists(path));\n\t\t// ::done\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "private boolean isUrlOk() {\n\t\t// ::comment when __CORE__\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)\n\t\t\t// In SANDBOX, we cannot read any URL\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.LEGACY)\n\t\t\treturn true;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE)\n\t\t\t// We are UNSECURE anyway\n\t\t\treturn true;\n\n\t\tif (isInUrlAllowList())\n\t\t\t// ::done\n\t\t\treturn true;\n\t\t// ::comment when __CORE__\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET) {\n\t\t\tif (forbiddenURL(cleanPath(internal.toString())))\n\t\t\t\treturn false;\n\n\t\t\tfinal int port = internal.getPort();\n\t\t\t// Using INTERNET profile, port 80 and 443 are ok\n\t\t\treturn port == 80 || port == 443 || port == -1;\n\t\t}\n\t\treturn false;\n\t\t// ::done\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "private boolean isFileOk() {\n\t\t// ::comment when __CORE__\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)\n\t\t\t// In SANDBOX, we cannot read any files\n\t\t\treturn false;\n\n\t\t// In any case SFile should not access the security folders\n\t\t// (the files must be handled internally)\n\t\ttry {\n\t\t\tif (isDenied())\n\t\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t\t// Files in \"plantuml.include.path\" and \"plantuml.allowlist.path\" are ok.\n\t\tif (isInAllowList(SecurityUtils.getPath(SecurityUtils.PATHS_INCLUDES)))\n\t\t\treturn true;\n\n\t\tif (isInAllowList(SecurityUtils.getPath(SecurityUtils.ALLOWLIST_LOCAL_PATHS)))\n\t\t\treturn true;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET)\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)\n\t\t\treturn false;\n\n\t\tif (SecurityUtils.getSecurityProfile() != SecurityProfile.UNSECURE) {\n\t\t\t// For UNSECURE, we did not do those checks\n\t\t\tfinal String path = getCleanPathSecure();\n\t\t\tif (path.startsWith(\"/etc/\") || path.startsWith(\"/dev/\") || path.startsWith(\"/boot/\")\n\t\t\t\t\t|| path.startsWith(\"/proc/\") || path.startsWith(\"/sys/\"))\n\t\t\t\treturn false;\n\n\t\t\tif (path.startsWith(\"//\"))\n\t\t\t\treturn false;\n\n\t\t}\n\t\t// ::done\n\t\treturn true;\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "public AFile getAFile(String nameOrPath) throws IOException {\n\t\t// Log.info(\"ImportedFiles::getAFile nameOrPath = \" + nameOrPath);\n\t\t// Log.info(\"ImportedFiles::getAFile currentDir = \" + currentDir);\n\t\tfinal AParentFolder dir = currentDir;\n\t\tif (dir == null || isAbsolute(nameOrPath)) {\n\t\t\treturn new AFileRegular(new SFile(nameOrPath).getCanonicalFile());\n\t\t}\n\t\t// final File filecurrent = SecurityUtils.File(dir.getAbsoluteFile(),\n\t\t// nameOrPath);\n\t\tfinal AFile filecurrent = dir.getAFile(nameOrPath);\n\t\tLog.info(\"ImportedFiles::getAFile filecurrent = \" + filecurrent);\n\t\tif (filecurrent != null && filecurrent.isOk()) {\n\t\t\treturn filecurrent;\n\t\t}\n\t\tfor (SFile d : getPath()) {\n\t\t\tif (d.isDirectory()) {\n\t\t\t\tfinal SFile file = d.file(nameOrPath);\n\t\t\t\tif (file.exists()) {\n\t\t\t\t\treturn new AFileRegular(file.getCanonicalFile());\n\t\t\t\t}\n\t\t\t} else if (d.isFile()) {\n\t\t\t\tfinal AFileZipEntry zipEntry = new AFileZipEntry(d, nameOrPath);\n\t\t\t\tif (zipEntry.isOk()) {\n\t\t\t\t\treturn zipEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn filecurrent;\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "public ImportedFiles withCurrentDir(AParentFolder newCurrentDir) {\n\t\tif (newCurrentDir == null) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new ImportedFiles(imported, newCurrentDir);\n\t}",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-40573",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "@Override\n    protected void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            JobDataMap data = jobContext.getJobDetail().getJobDataMap();\n\n            // Get the job XObject to be executed\n            BaseObject object = (BaseObject) data.get(\"xjob\");\n\n            // Force context document\n            XWikiDocument jobDocument = getXWikiContext().getWiki().getDocument(object.getName(), getXWikiContext());\n            getXWikiContext().setDoc(jobDocument);\n            getXWikiContext().put(\"sdoc\", jobDocument);\n\n            if (getXWikiContext().getWiki().getRightService().hasProgrammingRights(getXWikiContext())) {\n\n                // Make the Job execution data available to the Groovy script\n                Binding binding = new Binding(data.getWrappedMap());\n\n                // Set the right instance of XWikiContext\n                binding.setProperty(\"context\", getXWikiContext());\n                binding.setProperty(\"xcontext\", getXWikiContext());\n                data.put(\"xwiki\", new com.xpn.xwiki.api.XWiki(getXWikiContext().getWiki(), getXWikiContext()));\n\n                // Execute the Groovy script\n                GroovyShell shell = new GroovyShell(Thread.currentThread().getContextClassLoader(), binding);\n                shell.evaluate(object.getLargeStringValue(\"script\"));\n            } else {\n                throw new JobExecutionException(\"The user [\" + getXWikiContext().getUser() + \"] didn't have \"\n                    + \"programming rights when the job [\" + jobContext.getJobDetail().getKey() + \"] was scheduled.\");\n            }\n        } catch (CompilationFailedException e) {\n            throw new JobExecutionException(\n                \"Failed to execute script for job [\" + jobContext.getJobDetail().getKey() + \"]\", e, true);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }",
        "is_vul": true
    },
    {
        "cve_id": "CVE-2023-3431",
        "cwe_ids": [
            "CWE-284"
        ],
        "func_before": "public TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,\n\t\t\tMap<String, TValue> named) throws EaterException, EaterExceptionLocated {\n\t\t// ::comment when __CORE__\n\t\tif (OptionFlags.ALLOW_INCLUDE == false)\n\t\t\t// ::done\n\t\t\treturn TValue.fromString(\"\");\n\t\t// ::comment when __CORE__\n\n\t\tfinal String name = values.get(0).toString();\n\t\tfinal String value = getenv(name);\n\t\tif (value == null)\n\t\t\treturn TValue.fromString(\"\");\n\n\t\treturn TValue.fromString(value);\n\t\t// ::done\n\t}",
        "is_vul": true
    }
]